<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Will">
<meta property="og:url" content="http://yunheli.github.io/page/3/index.html">
<meta property="og:site_name" content="Will">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Will">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yunheli.github.io/page/3/">





  <title>Will</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Will</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">will's blogs</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yunheli.github.io/2014/02/11/2014-02-11-nosql-diff/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Will">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/02/11/2014-02-11-nosql-diff/" itemprop="url">MongoDB、Redis、Memcached 的不同？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-02-11T00:00:00+00:00">
                2014-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><h4 id="Memcached的优点："><a href="#Memcached的优点：" class="headerlink" title="Memcached的优点："></a><code>Memcached的优点：</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。</span><br><span class="line">支持直接配置为session handle。</span><br></pre></td></tr></table></figure>
<h4 id="Memcached的局限性："><a href="#Memcached的局限性：" class="headerlink" title="Memcached的局限性："></a><code>Memcached的局限性：</code></h4><pre><code>只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。
无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。
无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。
Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。
</code></pre><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis的优点："><a href="#Redis的优点：" class="headerlink" title="Redis的优点："></a><code>Redis的优点：</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）</span><br><span class="line">支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。</span><br><span class="line">支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。</span><br><span class="line">单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。</span><br><span class="line">支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。</span><br><span class="line">支持简单的事务需求，但业界使用场景很少，并不成熟。</span><br></pre></td></tr></table></figure>
<h4 id="Redis的局限性："><a href="#Redis的局限性：" class="headerlink" title="Redis的局限性："></a><code>Redis的局限性：</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。</span><br><span class="line">支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。</span><br><span class="line">Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。</span><br><span class="line">Mc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。比如redis的keys pattern这种匹配操作，对redis的性能是灾难。</span><br></pre></td></tr></table></figure>
<h3 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mongoDB 是一种文档性的数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。</span><br><span class="line">这些数据具备自述性（self-describing），呈现分层的树状数据结构。redis可以用hash存放简单关系型数据。</span><br><span class="line">mongoDB 存放json格式数据。</span><br><span class="line">适合场景：事件记录、内容管理或者博客平台，比如评论系统。</span><br></pre></td></tr></table></figure>
<h4 id="1-mongodb持久化原理"><a href="#1-mongodb持久化原理" class="headerlink" title="1.mongodb持久化原理"></a><code>1.mongodb持久化原理</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongodb与mysql不同，mysql的每一次更新操作都会直接写入硬盘，但是mongo不会，做为内存型数据库，数据操作会先写入内存，然后再会持久化到硬盘中去，那么mongo是如何持久化的呢</span><br><span class="line">mongodb在启动时，专门初始化一个线程不断循环（除非应用crash掉），用于在一定时间周期内来从defer队列中获取要持久化的数据并写入到磁盘的journal(日志)和mongofile(数据)处，当然因为它不是在用户添加记录时就写到磁盘上，所以按mongodb开发者说，它不会造成性能上的损耗，因为看过代码发现，当进行CUD操作时，记录(Record类型)都被放入到defer队列中以供延时批量（groupcommit）提交写入，但相信其中时间周期参数是个要认真考量的参数，系统为90毫秒，如果该值更低的话，可能会造成频繁磁盘操作，过高又会造成系统宕机时数据丢失过。</span><br></pre></td></tr></table></figure>
<h4 id="2-什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？"><a href="#2-什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？" class="headerlink" title="2.什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？"></a><code>2.什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NoSQL是非关系型数据库，NoSQL = Not Only SQL。</span><br><span class="line">关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。</span><br><span class="line">在处理非结构化/半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。</span><br><span class="line">在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。</span><br></pre></td></tr></table></figure>
<h4 id="3-MySQL和MongoDB之间最基本的区别是什么？"><a href="#3-MySQL和MongoDB之间最基本的区别是什么？" class="headerlink" title="3.MySQL和MongoDB之间最基本的区别是什么？"></a><code>3.MySQL和MongoDB之间最基本的区别是什么？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">关系型数据库与非关系型数据库的区别，即数据存储结构的不同。</span><br></pre></td></tr></table></figure>
<h4 id="4-MongoDB的特点是什么？"><a href="#4-MongoDB的特点是什么？" class="headerlink" title="4.MongoDB的特点是什么？"></a><code>4.MongoDB的特点是什么？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）面向文档</span><br><span class="line">（2）高性能</span><br><span class="line">（3）高可用</span><br><span class="line">（4）易扩展</span><br><span class="line">（5）丰富的查询语言</span><br></pre></td></tr></table></figure>
<h4 id="5-MongoDB支持存储过程吗？如果支持的话，怎么用？"><a href="#5-MongoDB支持存储过程吗？如果支持的话，怎么用？" class="headerlink" title="5.MongoDB支持存储过程吗？如果支持的话，怎么用？"></a><code>5.MongoDB支持存储过程吗？如果支持的话，怎么用？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。</span><br></pre></td></tr></table></figure>
<h4 id="6-如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？"><a href="#6-如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？" class="headerlink" title="6.如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？"></a><code>6.如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。</span><br></pre></td></tr></table></figure>
<h4 id="7-为什么MongoDB的数据文件很大？"><a href="#7-为什么MongoDB的数据文件很大？" class="headerlink" title="7.为什么MongoDB的数据文件很大？"></a><code>7.为什么MongoDB的数据文件很大？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoDB采用的预分配空间的方式来防止文件碎片。</span><br></pre></td></tr></table></figure>
<h4 id="8-当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？"><a href="#8-当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？" class="headerlink" title="8.当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？"></a><code>8.当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。</span><br></pre></td></tr></table></figure>
<h4 id="9-MongoDB在A-B-C-上建立索引，查询A-B-C-和A-C-B-都会使用索引吗？"><a href="#9-MongoDB在A-B-C-上建立索引，查询A-B-C-和A-C-B-都会使用索引吗？" class="headerlink" title="9.MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？"></a><code>9.MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不会，只会在A:&#123;B,C&#125;上使用索引。</span><br></pre></td></tr></table></figure>
<h4 id="10-如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？"><a href="#10-如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？" class="headerlink" title="10.如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？"></a><code>10.如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个分片停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB会等待它的响应。</span><br></pre></td></tr></table></figure>
<h3 id="Redis、Memcache和MongoDB的区别"><a href="#Redis、Memcache和MongoDB的区别" class="headerlink" title="Redis、Memcache和MongoDB的区别"></a>Redis、Memcache和MongoDB的区别</h3><p>从以下几个维度，对redis、memcache、mongoDB 做了对比，</p>
<h4 id="1、性能"><a href="#1、性能" class="headerlink" title="1、性能"></a><code>1、性能</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">都比较高，性能对我们来说应该都不是瓶颈</span><br><span class="line">总体来讲，TPS方面redis和memcache差不多，要大于mongodb</span><br></pre></td></tr></table></figure>
<h4 id="2、操作的便利性"><a href="#2、操作的便利性" class="headerlink" title="2、操作的便利性"></a><code>2、操作的便利性</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memcache数据结构单一</span><br><span class="line">redis丰富一些，数据操作方面，redis更好一些，较少的网络IO次数</span><br><span class="line">mongodb支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富</span><br></pre></td></tr></table></figure>
<h4 id="3、内存空间的大小和数据量的大小"><a href="#3、内存空间的大小和数据量的大小" class="headerlink" title="3、内存空间的大小和数据量的大小"></a><code>3、内存空间的大小和数据量的大小</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis在2.0版本后增加了自己的VM特性，突破物理内存的限制；可以对key value设置过期时间（类似memcache）</span><br><span class="line">memcache可以修改最大可用内存,采用LRU算法</span><br><span class="line">mongoDB适合大数据量的存储，依赖操作系统VM做内存管理，吃内存也比较厉害，服务不要和别的服务在一起</span><br></pre></td></tr></table></figure>
<h4 id="4、可用性（单点问题）"><a href="#4、可用性（单点问题）" class="headerlink" title="4、可用性（单点问题）"></a><code>4、可用性（单点问题）</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于单点问题，</span><br><span class="line">redis，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照,无增量复制，因性能和效率问题，</span><br><span class="line">所以单点问题比较复杂；不支持自动sharding,需要依赖程序设定一致hash 机制。</span><br><span class="line">一种替代方案是，不用redis本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡</span><br><span class="line">Memcache本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的hash或者环状的算法，解决单点故障引起的抖动问题。</span><br><span class="line">mongoDB支持master-slave,replicaset（内部采用paxos选举算法，自动故障恢复）,auto sharding机制，对客户端屏蔽了故障转移和切分机制。</span><br></pre></td></tr></table></figure>
<h4 id="5、可靠性（持久化）"><a href="#5、可靠性（持久化）" class="headerlink" title="5、可靠性（持久化）"></a><code>5、可靠性（持久化）</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于数据持久化和数据恢复，</span><br><span class="line">redis支持（快照、AOF）：依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响</span><br><span class="line">memcache不支持，通常用在做缓存,提升性能；</span><br><span class="line">MongoDB从1.8版本开始采用binlog方式支持持久化的可靠性</span><br></pre></td></tr></table></figure>
<h4 id="6、数据一致性（事务支持）"><a href="#6、数据一致性（事务支持）" class="headerlink" title="6、数据一致性（事务支持）"></a><code>6、数据一致性（事务支持）</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Memcache 在并发场景下，用cas保证一致性</span><br><span class="line">redis事务支持比较弱，只能保证事务中的每个操作连续执行</span><br><span class="line">mongoDB不支持事务</span><br></pre></td></tr></table></figure>
<h4 id="7、数据分析"><a href="#7、数据分析" class="headerlink" title="7、数据分析"></a><code>7、数据分析</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoDB内置了数据分析的功能(mapreduce),其他不支持</span><br></pre></td></tr></table></figure>
<h4 id="8、应用场景"><a href="#8、应用场景" class="headerlink" title="8、应用场景"></a><code>8、应用场景</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis：数据量较小的更性能操作和运算上</span><br><span class="line">memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）</span><br><span class="line">MongoDB:主要解决海量数据的访问效率问题</span><br></pre></td></tr></table></figure>
<ul>
<li>转自 <a href="https://yq.aliyun.com/articles/38224" target="_blank" rel="noopener">阿里云</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yunheli.github.io/2014/01/20/2014-1-20-mongodb-methods/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Will">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/20/2014-1-20-mongodb-methods/" itemprop="url">MongoDB 常用命令？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-01-20T00:00:00+00:00">
                2014-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、查询"><a href="#一、查询" class="headerlink" title="一、查询"></a>一、查询</h2><h3 id="find方法"><a href="#find方法" class="headerlink" title="find方法"></a><code>find方法</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.find();</span><br></pre></td></tr></table></figure>
<h3 id="查询所有的结果："><a href="#查询所有的结果：" class="headerlink" title="查询所有的结果："></a><code>查询所有的结果：</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from users;</span><br><span class="line">db.users.find();</span><br></pre></td></tr></table></figure>
<h3 id="指定返回那些列（键）："><a href="#指定返回那些列（键）：" class="headerlink" title="指定返回那些列（键）："></a><code>指定返回那些列（键）：</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name, skills from users;</span><br><span class="line">db.users.find(&#123;&#125;, &#123;&apos;name&apos; : 1, &apos;skills&apos; : 1&#125;);</span><br><span class="line">补充说明： 第一个&#123;&#125; 放where条件 第二个&#123;&#125; 指定那些列显示和不显示 （0表示不显示 1表示显示)</span><br></pre></td></tr></table></figure>
<h3 id="where条件："><a href="#where条件：" class="headerlink" title="where条件："></a><code>where条件：</code></h3><h4 id="1-简单的等于"><a href="#1-简单的等于" class="headerlink" title="1.简单的等于:"></a><code>1.简单的等于:</code></h4><pre><code>select name, age, skills from users where name = &apos;hurry&apos;;
db.users.find({&apos;name&apos; : &apos;hurry&apos;},{&apos;name&apos; : 1, &apos;age&apos; : 1, &apos;skills&apos; : 1});
</code></pre><h4 id="2-使用and"><a href="#2-使用and" class="headerlink" title="2.使用and"></a><code>2.使用and</code></h4><pre><code>select name, age, skills from users where name = &apos;hurry&apos; and age = 18;
db.users.find({&apos;name&apos; : &apos;hurry&apos;, &apos;age&apos; : 18},{&apos;name&apos; : 1, &apos;age&apos; : 1, &apos;skills&apos; : 1});
</code></pre><h4 id="3-使用or"><a href="#3-使用or" class="headerlink" title="3.使用or"></a><code>3.使用or</code></h4><pre><code>select name, age, skills from users where name = &apos;hurry&apos; or age = 18;
db.users.find({ &apos;$or&apos; : [{&apos;name&apos; : &apos;hurry&apos;}, {&apos;age&apos; : 18}] },{&apos;name&apos; : 1, &apos;age&apos; : 1, &apos;skills&apos; : 1});
</code></pre><h4 id="4-lt-lt-gt-gt-lt-lte-gt-gte"><a href="#4-lt-lt-gt-gt-lt-lte-gt-gte" class="headerlink" title="4.&lt;, &lt;=, &gt;, &gt;= ($lt, $lte, $gt, $gte )"></a><code>4.&lt;, &lt;=, &gt;, &gt;= ($lt, $lte, $gt, $gte )</code></h4><pre><code>select * from users where age &gt;= 20 and age &lt;= 30;
db.users.find({&apos;age&apos; : {&apos;$gte&apos; : 20, &apos;$lte&apos; : 30}});
</code></pre><h4 id="5-使用in-not-in-in-nin"><a href="#5-使用in-not-in-in-nin" class="headerlink" title="5.使用in, not in ($in, $nin)"></a><code>5.使用in, not in ($in, $nin)</code></h4><pre><code>select * from users where age in (10, 22, 26);
db.users.find({&apos;age&apos; : {&apos;$in&apos; : [10, 22, 26]}});
</code></pre><h4 id="6-匹配null"><a href="#6-匹配null" class="headerlink" title="6.匹配null"></a><code>6.匹配null</code></h4><pre><code>select * from users where age is null;
db.users.find({&apos;age&apos; : null);
</code></pre><h4 id="7-like-mongoDB-支持正则表达式"><a href="#7-like-mongoDB-支持正则表达式" class="headerlink" title="7.like (mongoDB 支持正则表达式)"></a><code>7.like (mongoDB 支持正则表达式)</code></h4><pre><code>select * from users where name like &quot;%hurry%&quot;;
db.users.find({name:/hurry/});
select * from users where name like &quot;hurry%&quot;;
db.users.find({name:/^hurry/});
</code></pre><h4 id="8-使用distinct"><a href="#8-使用distinct" class="headerlink" title="8.使用distinct"></a><code>8.使用distinct</code></h4><pre><code>select distinct (name) from users;
db.users.distinct(&apos;name&apos;);
</code></pre><h4 id="9-使用count"><a href="#9-使用count" class="headerlink" title="9.使用count"></a><code>9.使用count</code></h4><pre><code>select count(*) from users;
db.users.count();
</code></pre><h4 id="10-数组查询-（mongoDB自己特有的）"><a href="#10-数组查询-（mongoDB自己特有的）" class="headerlink" title="10.数组查询 （mongoDB自己特有的）"></a><code>10.数组查询 （mongoDB自己特有的）</code></h4><pre><code>如果skills是 [&apos;java&apos;,&apos;python&apos;]
db.users.find({&apos;skills&apos; : &apos;java&apos;}); 该语句可以匹配成功
$all
db.users.find({&apos;skills&apos; : {&apos;$all&apos; : [&apos;java&apos;,&apos;python&apos;]}}) skills中必须同时包含java 和 python
$size
db.users.find({&apos;skills&apos; : {&apos;$size&apos; : 2}}) 遗憾的是$size不能与$lt等组合使用
$slice
db.users.find({&apos;skills&apos; : {&apos;$slice : [1,1]}})
两个参数分别是偏移量和返回的数量
</code></pre><h4 id="11-查询内嵌文档"><a href="#11-查询内嵌文档" class="headerlink" title="11.查询内嵌文档"></a><code>11.查询内嵌文档</code></h4><h4 id="12-强大的-where查询"><a href="#12-强大的-where查询" class="headerlink" title="12.强大的$where查询"></a><code>12.强大的$where查询</code></h4><pre><code>db.foo.find();
{ &quot;_id&quot; : ObjectId(&quot;4e17ce0ac39f1afe0ba78ce4&quot;), &quot;a&quot; : 1, &quot;b&quot; : 3, &quot;c&quot; : 10 }
{ &quot;_id&quot; : ObjectId(&quot;4e17ce13c39f1afe0ba78ce5&quot;), &quot;a&quot; : 1, &quot;b&quot; : 6, &quot;c&quot; : 6 }
如果要查询 b = c 的文档怎么办？
&gt; db.foo.find({&quot;$where&quot;:function(){
    for(var current in this){
        for(var other in this){
            if(current != other &amp;&amp; this[current] == this[other]){
                return true;
            }
        }
    }
    return false;
}});

{ &quot;_id&quot; : ObjectId(&quot;4e17ce13c39f1afe0ba78ce5&quot;), &quot;a&quot; : 1, &quot;b&quot; : 6, &quot;c&quot; : 6 }

  1 ) `. 大于，小于，大于或等于，小于或等于`
  $gt:大于
  $lt:小于
  $gte:大于或等于
  $lte:小于或等于
  例子：
  db.collection.find({ &quot;field&quot; : { $gt: value } } ); // greater than : field &gt; value
  db.collection.find({ &quot;field&quot; : { $lt: value } } ); // less than : field &lt; value
  db.collection.find({ &quot;field&quot; : { $gte: value } } ); // greater than or equal to : field &gt;= value
  db.collection.find({ &quot;field&quot; : { $lte: value } } ); // less than or equal to : field &lt;= value

  如查询j大于3,小于4:

  db.things.find({j : {$lt: 3}});
  db.things.find({j : {$gte: 4}});

  也可以合并在一条语句内:

  db.collection.find({ &quot;field&quot; : { $gt: value1, $lt: value2 } } ); // value1 &lt; field &lt; value



  2) 不等于 $ne
  例子：

  db.things.find( { x : { $ne : 3 } } );


  3) in 和 not in ($in $nin)
  语法：
  db.collection.find( { &quot;field&quot; : { $in : array } } );

  例子：

  db.things.find({j:{$in: [2,4,6]}});

  db.things.find({j:{$nin: [2,4,6]}});

  4) 取模运算$mod
  如下面的运算：
  db.things.find( &quot;this.a % 10 == 1&quot;)

  可用$mod代替：

  db.things.find( { a : { $mod : [ 10 , 1 ] } } )

  5)  $all
  $all和$in类似，但是他需要匹配条件内所有的值：
  如有一个对象：
  { a: [ 1, 2, 3 ] }

  下面这个条件是可以匹配的：

  db.things.find( { a: { $all: [ 2, 3 ] } } );

  但是下面这个条件就不行了：

  db.things.find( { a: { $all: [ 2, 3, 4 ] } } );

  6)  $size
  $size是匹配数组内的元素数量的，如有一个对象：{a:[&quot;foo&quot;]}，他只有一个元素：
  下面的语句就可以匹配：
  db.things.find( { a : { $size: 1 } } );

  官网上说不能用来匹配一个范围内的元素，如果想找$size&lt;5之类的，他们建议创建一个字段来保存元素的数量。
  You cannot use $size to find a range of sizes (for example: arrays with more than 1 element). If you need to query for a range, create an extra size field that you increment when you add elements.

  7）$exists
  $exists用来判断一个元素是否存在：
  如：

  db.things.find( { a : { $exists : true } } ); // 如果存在元素a,就返回
  db.things.find( { a : { $exists : false } } ); // 如果不存在元素a，就返回

  8)  $type
  $type 基于 bson type来匹配一个元素的类型，像是按照类型ID来匹配，不过我没找到bson类型和id对照表。

  db.things.find( { a : { $type : 2 } } ); // matches if a is a string
  db.things.find( { a : { $type : 16 } } ); // matches if a is an int

  9）正则表达式
  mongo支持正则表达式，如：
  db.customers.find( { name : /acme.*corp/i } ); // 后面的i的意思是区分大小写

  10)  查询数据内的值
  下面的查询是查询colors内red的记录，如果colors元素是一个数据,数据库将遍历这个数组的元素来查询。
  db.things.find( { colors : &quot;red&quot; } );

  11) $elemMatch
  如果对象有一个元素是数组，那么$elemMatch可以匹配内数组内的元素：
  &gt; t.find( { x : { $elemMatch : { a : 1, b : { $gt : 1 } } } } )
  { &quot;_id&quot; : ObjectId(&quot;4b5783300334000000000aa9&quot;),
  &quot;x&quot; : [ { &quot;a&quot; : 1, &quot;b&quot; : 3 }, 7, { &quot;b&quot; : 99 }, { &quot;a&quot; : 11 } ]
  }
  $elemMatch : { a : 1, b : { $gt : 1 } } 所有的条件都要匹配上才行。
  注意，上面的语句和下面是不一样的。

  &gt; t.find( { &quot;x.a&quot; : 1, &quot;x.b&quot; : { $gt : 1 } } )
  $elemMatch是匹配{ &quot;a&quot; : 1, &quot;b&quot; : 3 }，而后面一句是匹配{ &quot;b&quot; : 99 }, { &quot;a&quot; : 11 }

  12)  查询嵌入对象的值
  db.postings.find( { &quot;author.name&quot; : &quot;joe&quot; } );

  注意用法是author.name，用一个点就行了。更详细的可以看这个链接： dot notation
  举个例子：

  &gt; db.blog.save({ title : &quot;My First Post&quot;, author: {name : &quot;Jane&quot;, id : 1}})

  如果我们要查询 authors name 是Jane的, 我们可以这样：

  &gt; db.blog.findOne({&quot;author.name&quot; : &quot;Jane&quot;})

  如果不用点，那就需要用下面这句才能匹配：

  db.blog.findOne({&quot;author&quot; : {&quot;name&quot; : &quot;Jane&quot;, &quot;id&quot; : 1}})

  下面这句：

  db.blog.findOne({&quot;author&quot; : {&quot;name&quot; : &quot;Jane&quot;}})

  是不能匹配的，因为mongodb对于子对象，他是精确匹配。

  13) 元操作符 $not 取反
  如：

  db.customers.find( { name : { $not : /acme.*corp/i } } );

  db.things.find( { a : { $not : { $mod : [ 10 , 1 ] } } } );
  mongodb还有很多函数可以用，如排序，统计等，请参考原文。

  mongodb目前没有或(or)操作符，只能用变通的办法代替，可以参考下面的链接：

  http://www.mongodb.org/display/DOCS/OR+operations+in+query+expressions
  分类: MongoDB
</code></pre><h2 id="二、更新"><a href="#二、更新" class="headerlink" title="二、更新"></a>二、更新</h2><pre><code>mongodb更新有两个命令：
</code></pre><h4 id="1-update-命令"><a href="#1-update-命令" class="headerlink" title="1).update()命令"></a><code>1).update()命令</code></h4><pre><code>db.collection.update( criteria, objNew, upsert, multi )

criteria : update的查询条件，类似sql update查询内where后面的
objNew   : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的
upsert   : 这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。
multi    : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。

例：
db.test0.update( { &quot;count&quot; : { $gt : 1 } } , { $set : { &quot;test2&quot; : &quot;OK&quot;} } ); 只更新了第一条记录
db.test0.update( { &quot;count&quot; : { $gt : 3 } } , { $set : { &quot;test2&quot; : &quot;OK&quot;} },false,true ); 全更新了
db.test0.update( { &quot;count&quot; : { $gt : 4 } } , { $set : { &quot;test5&quot; : &quot;OK&quot;} },true,false ); 只加进去了第一条
db.test0.update( { &quot;count&quot; : { $gt : 5 } } , { $set : { &quot;test5&quot; : &quot;OK&quot;} },true,true ); 全加进去了
db.test0.update( { &quot;count&quot; : { $gt : 15 } } , { $inc : { &quot;count&quot; : 1} },false,true );全更新了
db.test0.update( { &quot;count&quot; : { $gt : 10 } } , { $inc : { &quot;count&quot; : 1} },false,false );只更新了第一条
</code></pre><h4 id="2-save-命令"><a href="#2-save-命令" class="headerlink" title="2).save()命令"></a><code>2).save()命令</code></h4><pre><code>db.collection.save( x )

x就是要更新的对象，只能是单条记录。

如果在collection内已经存在一个和x对象相同的&quot;_id&quot;的记录。mongodb就会把x对象替换collection内已经存在的记录，否则将会插入x对象，如果x内没有_id,系统会自动生成一个再插入。相当于上面update语句的upsert=true,multi=false的情况。
例：
db.test0.save({count:40,test1:&quot;OK&quot;}); #_id系统会生成
db.test0.save({_id:40,count:40,test1:&quot;OK&quot;}); #如果test0内有_id等于40的，会替换，否则插入。

mongodb的更新操作符：
1) $inc
用法：{ $inc : { field : value } }
意思对一个数字字段field增加value，例：
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 16, &quot;test1&quot; : &quot;TESTTEST&quot;, &quot;test2&quot; : &quot;OK&quot;, &quot;test3&quot; : &quot;TESTTEST&quot;, &quot;test4&quot; : &quot;OK&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $inc : { &quot;count&quot; : 1 } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 17, &quot;test1&quot; : &quot;TESTTEST&quot;, &quot;test2&quot; : &quot;OK&quot;, &quot;test3&quot; : &quot;TESTTEST&quot;, &quot;test4&quot; : &quot;OK&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $inc : { &quot;count&quot; : 2 } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 19, &quot;test1&quot; : &quot;TESTTEST&quot;, &quot;test2&quot; : &quot;OK&quot;, &quot;test3&quot; : &quot;TESTTEST&quot;, &quot;test4&quot; : &quot;OK&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $inc : { &quot;count&quot; : -1 } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : &quot;TESTTEST&quot;, &quot;test2&quot; : &quot;OK&quot;, &quot;test3&quot; : &quot;TESTTEST&quot;, &quot;test4&quot; : &quot;OK&quot;, &quot;test5&quot; : &quot;OK&quot; }

2) $set
用法：{ $set : { field : value } }
就是相当于sql的set field = value，全部数据类型都支持$set。例：
&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $set : { &quot;test1&quot; : &quot;testv1&quot;,&quot;test2&quot; : &quot;testv2&quot;,&quot;test3&quot; : &quot;testv3&quot;,&quot;test4&quot; : &quot;testv4&quot; } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : &quot;testv1&quot;, &quot;test2&quot; : &quot;testv2&quot;, &quot;test3&quot; : &quot;testv3&quot;, &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }
</code></pre><h4 id="3-unset"><a href="#3-unset" class="headerlink" title="3) $unset"></a><code>3) $unset</code></h4><pre><code>用法：{ $unset : { field : 1} }
顾名思义，就是删除字段了。例：
&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $unset : { &quot;test1&quot;:1 } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test2&quot; : &quot;testv2&quot;, &quot;test3&quot; : &quot;testv3&quot;, &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $unset : { &quot;test2&quot;: 0 } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test3&quot; : &quot;testv3&quot;, &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $unset : { &quot;test3&quot;:asdfasf } } );
Fri May 14 16:17:38 JS Error: ReferenceError: asdfasf is not defined (shell):0

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $unset : { &quot;test3&quot;:&quot;test&quot; } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }

没看出field : 1里面的1是干什么用的，反正只要有东西就行。
</code></pre><h4 id="4-push"><a href="#4-push" class="headerlink" title="4) $push"></a><code>4) $push</code></h4><pre><code>用法：{ $push : { field : value } }
把value追加到field里面去，field一定要是数组类型才行，如果field不存在，会新增一个数组类型加进去。例：

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $set : { &quot;test1&quot; : [&quot;aaa&quot;,&quot;bbb&quot;] } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;aaa&quot;, &quot;bbb&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $push : { &quot;test1&quot;: &quot;ccc&quot; } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $push : { &quot;test2&quot;: &quot;ccc&quot; } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot; ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $push : { &quot;test1&quot;: [&quot;ddd&quot;,&quot;eee&quot;] } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, [ &quot;ddd&quot;, &quot;eee&quot; ] ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }5) $pushAll
</code></pre><h4 id="5-pushAll"><a href="#5-pushAll" class="headerlink" title="5) $pushAll"></a><code>5) $pushAll</code></h4><pre><code>用法：{ $pushAll : { field : value_array } }
同$push,只是一次可以追加多个值到一个数组字段内。例：
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, [ &quot;ddd&quot;, &quot;eee&quot; ] ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $pushAll : { &quot;test1&quot;: [&quot;fff&quot;,&quot;ggg&quot;] } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, [ &quot;ddd&quot;, &quot;eee&quot; ], &quot;fff&quot;, &quot;ggg&quot; ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }
</code></pre><h4 id="6-addToSet"><a href="#6-addToSet" class="headerlink" title="6)  $addToSet"></a><code>6)  $addToSet</code></h4><pre><code>用法：{ $addToSet : { field : value } }
增加一个值到数组内，而且只有当这个值不在数组内才增加。例：
&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $addToSet : { &quot;test1&quot;: {$each : [&quot;444&quot;,&quot;555&quot;] } } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18,

  &quot;test1&quot; : [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,[&quot;ddd&quot;,&quot;eee&quot;],&quot;fff&quot;,&quot;ggg&quot;,[&quot;111&quot;,&quot;222&quot;],&quot;444&quot;,&quot;555&quot;],

  &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot;

 }
&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $addToSet : { &quot;test1&quot;: {$each : [&quot;444&quot;,&quot;555&quot;] } } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18,

  &quot;test1&quot; : [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,[&quot;ddd&quot;,&quot;eee&quot;],&quot;fff&quot;,&quot;ggg&quot;,[&quot;111&quot;,&quot;222&quot;],&quot;444&quot;,&quot;555&quot;], &quot;test2&quot; : [ &quot;ccc&quot; ],

  &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot;

}
&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $addToSet : { &quot;test1&quot;: [&quot;444&quot;,&quot;555&quot;] } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18,

  &quot;test1&quot; : [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,[&quot;ddd&quot;,&quot;eee&quot;],&quot;fff&quot;,&quot;ggg&quot;,[&quot;111&quot;,&quot;222&quot;],&quot;444&quot;,&quot;555&quot;,[&quot;444&quot;,&quot;555&quot;]], &quot;test2&quot; : [ &quot;ccc&quot; ],

  &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot;

}
&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $addToSet : { &quot;test1&quot;: [&quot;444&quot;,&quot;555&quot;] } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,[&quot;ddd&quot;,&quot;eee&quot;],&quot;fff&quot;,&quot;ggg&quot;,[&quot;111&quot;,&quot;222&quot;],&quot;444&quot;,&quot;555&quot;,[&quot;444&quot;,&quot;555&quot;]], &quot;test2&quot; : [ &quot;ccc&quot; ],

  &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot;

}
</code></pre><h4 id="7-pop"><a href="#7-pop" class="headerlink" title="7) $pop"></a><code>7) $pop</code></h4><pre><code>删除数组内的一个值
用法：
删除最后一个值：{ $pop : { field : 1 } }删除第一个值：{ $pop : { field : -1 } }
注意，只能删除一个值，也就是说只能用1或-1，而不能用2或-2来删除两条。mongodb 1.1及以后的版本才可以用，例：
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18,

  &quot;test1&quot; : [&quot;bbb&quot;,&quot;ccc&quot;,[&quot;ddd&quot;,&quot;eee&quot;],&quot;fff&quot;,&quot;ggg&quot;,[&quot;111&quot;,&quot;222&quot;],&quot;444&quot;],

  &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot;

}
&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $pop : { &quot;test1&quot;: -1 } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18,

  &quot;test1&quot; : [&quot;ccc&quot;,[&quot;ddd&quot;,&quot;eee&quot;],&quot;fff&quot;,&quot;ggg&quot;,[&quot;111&quot;,&quot;222&quot;],&quot;444&quot;],

  &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot;

 }
&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $pop : { &quot;test1&quot;: 1 } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18,

  &quot;test1&quot; : [ &quot;ccc&quot;, [ &quot;ddd&quot;, &quot;eee&quot; ], &quot;fff&quot;, &quot;ggg&quot;, [ &quot;111&quot;, &quot;222&quot; ] ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;,
  &quot;test5&quot; : &quot;OK&quot;

}
</code></pre><h4 id="8-pull"><a href="#8-pull" class="headerlink" title="8) $pull"></a><code>8) $pull</code></h4><pre><code>用法：$pull : { field : value } }
从数组field内删除一个等于value值。例：
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;ccc&quot;, [ &quot;ddd&quot;, &quot;eee&quot; ], &quot;fff&quot;, &quot;ggg&quot;, [ &quot;111&quot;, &quot;222&quot; ] ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;,
&quot;test5&quot; : &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $pull : { &quot;test1&quot;: &quot;ggg&quot; } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;ccc&quot;, [ &quot;ddd&quot;, &quot;eee&quot; ], &quot;fff&quot;, [ &quot;111&quot;, &quot;222&quot; ] ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot;
: &quot;OK&quot; }
</code></pre><h4 id="9-pullAll"><a href="#9-pullAll" class="headerlink" title="9) $pullAll"></a><code>9) $pullAll</code></h4><pre><code>用法：{ $pullAll : { field : value_array } }
同$pull,可以一次删除数组内的多个值。例：
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ &quot;ccc&quot;, [ &quot;ddd&quot;, &quot;eee&quot; ], &quot;fff&quot;, [ &quot;111&quot;, &quot;222&quot; ] ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot;
: &quot;OK&quot; }

&gt; db.test0.update( { &quot;_id&quot; : 15 } , { $pullAll : { &quot;test1&quot;: [ &quot;ccc&quot; , &quot;fff&quot; ] } } );
&gt; db.test0.find( { &quot;_id&quot; : 15 } );
{ &quot;_id&quot; : { &quot;floatApprox&quot; : 15 }, &quot;count&quot; : 18, &quot;test1&quot; : [ [ &quot;ddd&quot;, &quot;eee&quot; ], [ &quot;111&quot;, &quot;222&quot; ] ], &quot;test2&quot; : [ &quot;ccc&quot; ], &quot;test4&quot; : &quot;testv4&quot;, &quot;test5&quot; : &quot;OK&quot; }
</code></pre><h4 id="10-操作符"><a href="#10-操作符" class="headerlink" title="10) $ 操作符"></a><code>10) $ 操作符</code></h4><pre><code>$是他自己的意思，代表按条件找出的数组里面某项他自己。呵呵，比较坳口。看一下官方的例子：
&gt; t.find()
{ &quot;_id&quot; : ObjectId(&quot;4b97e62bf1d8c7152c9ccb74&quot;), &quot;title&quot; : &quot;ABC&quot;, &quot;comments&quot; : [ { &quot;by&quot; : &quot;joe&quot;, &quot;votes&quot; : 3 }, { &quot;by&quot; : &quot;jane&quot;, &quot;votes&quot; : 7 } ] }

&gt; t.update( {&apos;comments.by&apos;:&apos;joe&apos;}, {$inc:{&apos;comments.$.votes&apos;:1}}, false, true )

&gt; t.find()
{ &quot;_id&quot; : ObjectId(&quot;4b97e62bf1d8c7152c9ccb74&quot;), &quot;title&quot; : &quot;ABC&quot;, &quot;comments&quot; : [ { &quot;by&quot; : &quot;joe&quot;, &quot;votes&quot; : 4 }, { &quot;by&quot; : &quot;jane&quot;, &quot;votes&quot; : 7 } ] }

需要注意的是，$只会应用找到的第一条数组项，后面的就不管了。还是看例子：
&gt; t.find();
{ &quot;_id&quot; : ObjectId(&quot;4b9e4a1fc583fa1c76198319&quot;), &quot;x&quot; : [ 1, 2, 3, 2 ] }
&gt; t.update({x: 2}, {$inc: {&quot;x.$&quot;: 1}}, false, true);
&gt; t.find();

还有注意的是$配合$unset使用的时候，会留下一个null的数组项，不过可以用{$pull:{x:null}}删除全部是null的数组项。例：
&gt; t.insert({x: [1,2,3,4,3,2,3,4]})
&gt; t.find()
{ &quot;_id&quot; : ObjectId(&quot;4bde2ad3755d00000000710e&quot;), &quot;x&quot; : [ 1, 2, 3, 4, 3, 2, 3, 4 ] }
&gt; t.update({x:3}, {$unset:{&quot;x.$&quot;:1}})
&gt; t.find()
{ &quot;_id&quot; : ObjectId(&quot;4bde2ad3755d00000000710e&quot;), &quot;x&quot; : [ 1, 2, null, 4, 3, 2, 3, 4 ] }

{ &quot;_id&quot; : ObjectId(&quot;4b9e4a1fc583fa1c76198319&quot;), &quot;x&quot; : [ 1, 3, 3, 2 ] }





============  数组元素操作示例 ================

&gt; db.arraytest.insert({id:2, name:&apos;leon&apos;, comments:[{id:&apos;011&apos;, content:&apos;cmt11&apos;}, {id:&apos;012&apos;, content:&apos;cmt12&apos;}, {id:&apos;013&apos;, content:&apos;cmt13&apos;}]})

1. 数组内的元素可以直接查询
&gt; db.arraytest.find({&apos;comments.id&apos;:&apos;002&apos;})
2. 更新数组中的某个节点的值,用$符号
db.arraytest.update({&apos;comments.id&apos;:&apos;012&apos;}, {$set: {&apos;comments.$.content&apos;:&apos;cmtttt012&apos;}})
3. 删除数组中的某一列，变成null
&gt; db.arraytest.update({&apos;comments.id&apos;:&apos;012&apos;}, {$unset: {&apos;comments.$&apos;:1}})
 4. 向数组中添加一个元素，如果之前没有元素则会新建数组
&gt; db.arraytest.update({&apos;comments.id&apos;:&apos;112&apos;}, {$push: {&apos;comments.$.reply&apos;: {&apos;rid&apos;:&apos;r21&apos;, content:&apos;reply22&apos;}}})
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yunheli.github.io/2014/01/12/2014-01-12-mongodb-hole/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Will">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/12/2014-01-12-mongodb-hole/" itemprop="url">MongoDB遇到的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-01-12T00:00:00+00:00">
                2014-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>MongoDB 是目前炙手可热的 NoSQL 文档型数据库，它提供的一些特性很棒：如自动 failover 机制，自动 sharding，无模式 schemaless，大部分情况下性能也很棒。但是薄荷在深入使用 MongoDB 过程中，遇到了不少问题，下面总结几个我们遇到的坑</p>
</blockquote>
<h4 id="MongoDB-Key的插入坑"><a href="#MongoDB-Key的插入坑" class="headerlink" title="MongoDB Key的插入坑"></a>MongoDB Key的插入坑</h4><p>也就是说在插入字段时属性一定不要带着”a.b.c”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.users.insert(&#123;&quot;a.b.c&quot;: 1&#125;)</span><br><span class="line">can&apos;t have . in field names [a.b.c] at src/mongo/shell/collection.js:155</span><br></pre></td></tr></table></figure>
<p>但是在更新时需要注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.users.update(&#123;_id: ObjectId(&quot;5722ac35e25a087137d138e3&quot;)&#125;,&#123;$set:&#123; &quot;a.b.c&quot; : 1 &#125;&#125;)</span><br><span class="line"> &#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;5722ac35e25a087137d138e3&quot;),</span><br><span class="line">&quot;a_b_c&quot; : 1,</span><br><span class="line">&quot;a&quot; : 1,</span><br><span class="line">&quot;x&quot; : &#123;</span><br><span class="line">	&quot;b&quot; : &#123;</span><br><span class="line">		&quot;c&quot; : 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 都转化成对象了</span><br></pre></td></tr></table></figure>
<p><code>另外注意一点，当存在属性a再去set a.b.c 是不成立的</code></p>
<p><code>注意几点： insert添加的属性中包含.是不合法的， update更新的hash里面的key中带有.也是不合法的</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.users.update(&#123;_id: ObjectId(&quot;5722ac35e25a087137d138e3&quot;)&#125;,&#123;$set:&#123; &quot;hash&quot; : &#123;&quot;e.c.v.b&quot;: 1&#125; &#125;&#125;)</span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	&quot;nMatched&quot; : 0,</span><br><span class="line">	&quot;nUpserted&quot; : 0,</span><br><span class="line">	&quot;nModified&quot; : 0,</span><br><span class="line">	&quot;writeError&quot; : &#123;</span><br><span class="line">		&quot;code&quot; : 57,</span><br><span class="line">		&quot;errmsg&quot; : &quot;The dotted field &apos;e.c.v.b&apos; in &apos;hash.e.c.v.b&apos; is not valid for storage.&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="MongoDB的锁的问题"><a href="#MongoDB的锁的问题" class="headerlink" title="MongoDB的锁的问题"></a>MongoDB的锁的问题</h4><pre><code>MongoDB的锁机制和一般关系数据库如 MySQL（InnoDB）, Oracle 有很大的差异，InnoDB 和 Oracle 能提供行级粒度锁，而 MongoDB 只能提供 库级粒度锁，这意味着当 MongoDB 一个写锁处于占用状态时，其它的读写操作都得干等。

初看起来库级锁在大并发环境下有严重的问题，但是 MongoDB 依然能够保持大并发量和高性能，这是因为 MongoDB 的锁粒度虽然很粗放，但是在锁处理机制和关系数据库锁有很大差异，主要表现在：
MongoDB 没有完整事务支持，操作原子性只到单个 document 级别，所以通常操作粒度比较小；
MongoDB 锁实际占用时间是内存数据计算和变更时间，通常很快；
MongoDB 锁有一种临时放弃机制，当出现需要等待慢速 IO 读写数据时，可以先临时放弃，等 IO 完成之后再重新获取锁。

通常不出问题不等于没有问题，如果数据操作不当，依然会导致长时间占用写锁，比如下面提到的前台建索引操作，当出现这种情况的时候，整个数据库就处于完全阻塞状态，无法进行任何读写操作，情况十分严重。

解决问题的方法，尽量避免长时间占用写锁操作，如果有一些集合操作实在难以避免，可以考虑把这个集合放到一个单独的 MongoDB 库里，因为 MongoDB 不同库锁是相互隔离的，分离集合可以避免某一个集合操作引发全局阻塞问题
</code></pre><h4 id="建索引导致数据库阻塞"><a href="#建索引导致数据库阻塞" class="headerlink" title="建索引导致数据库阻塞"></a>建索引导致数据库阻塞</h4><pre><code>上面提到了 MongoDB 库级锁的问题，建索引就是一个容易引起长时间写锁的问题，MongoDB 在前台建索引时需要占用一个写锁（而且不会临时放弃），如果集合的数据量很大，建索引通常要花比较长时间，特别容易引起问题。
解决的方法很简单，MongoDB 提供了两种建索引的访问，一种是 background 方式，不需要长时间占用写锁，另一种是非 background 方式，需要长时间占用锁。使用 background 方式就可以解决问题。 例如，为超大表 posts 建立索引， 千万不用使用
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.posts.ensureIndex(&#123;user_id: 1&#125;)</span><br></pre></td></tr></table></figure>
<p>而应该使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.posts.ensureIndex(&#123;user_id: 1&#125;, &#123;background: 1&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="不合理使用嵌入-embed-document"><a href="#不合理使用嵌入-embed-document" class="headerlink" title="不合理使用嵌入 embed document"></a>不合理使用嵌入 embed document</h4><pre><code>embed document 是 MongoDB 相比关系数据库差异明显的一个地方，可以在某一个 document 中嵌入其它子 document，这样可以在父子 document 保持在单一 collection 中，检索修改比较方便。

比如薄荷的应用情景中有一个 Group document，用户申请加入 Group 建模为 GroupRequest document，我们最初的时候使用 embed 方式把 GroupRequest 放置到 Group 中。 Ruby 代码如下所示（使用了 Mongoid ORM）:
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Group</span><br><span class="line">  include Mongoid::Document</span><br><span class="line">  ...</span><br><span class="line">  embeds_many :group_requests</span><br><span class="line">  ...</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">class GroupRequest</span><br><span class="line">  include Mongoid::Document</span><br><span class="line">  ...</span><br><span class="line">  embedded_in :group</span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<pre><code>这个使用方式让我们掉到坑里了，差点就爬不出来，它导致有接近两周的时间系统问题，高峰时段常有几分钟的系统卡顿，最严重一次甚至引起 MongoDB 宕机。

仔细分析后，发现某些活跃的 Group 的 group_requests 增加（当有新申请时）和更改（当通过或拒绝用户申请时）异常频繁，而这些操作经常长时间占用写锁，导致整个数据库阻塞。原因是当有增加 group_request 操作时，Group 预分配的空间不够，需要重新分配空间（内存和硬盘都需要），耗时较长，另外 Group 上建的索引很多，移动 Group 位置导致大量索引更新操作也很耗时，综合起来引起了长时间占用锁问题。

解决问题的方法，说起来也简单，就是把 embed 关联更改成的普通外键关联，就是类似关系数据库的做法，这样 group_request 增加或修改都只发生在 GroupRequest 上，简单快速，避免长时间占用写锁问题。当关联对象的数据不固定或者经常发生变化时，一定要避免使用 embed 关联，不然会死的很惨。
</code></pre><h4 id="不合理使用-Array-字段"><a href="#不合理使用-Array-字段" class="headerlink" title="不合理使用 Array 字段"></a>不合理使用 Array 字段</h4><pre><code>MongoDB 的 Array 字段是比较独特的一个特性，它可以在单个 document 里存储一些简单的一对多关系。

薄荷有一个应用情景使用遇到严重的性能问题，直接上代码如下所示：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User</span><br><span class="line">  include Mongoid::Document</span><br><span class="line">  ...</span><br><span class="line">  field :follower_user_ids, type: Array, default: []</span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h6><ul>
<li><a href="https://docs.mongodb.org/manual/faq/concurrency/" target="_blank" rel="noopener">MongoDB 锁机制详解</a></li>
<li><a href="https://docs.mongodb.org/manual/core/index-creation/" target="_blank" rel="noopener">MongoDB 建立索引操作文档</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yunheli.github.io/2014/01/08/2014-01-8-why-use-mongodb/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Will">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/08/2014-01-8-why-use-mongodb/" itemprop="url">为什么要用MongoDB？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-01-08T00:00:00+00:00">
                2014-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在做产品选型的时候总是要考虑为什么要用mongodb,为什么不选择MySql等关系行数据库呢,有如下几点</p>
</blockquote>
<ul>
<li>需求变化频繁：开发要更加敏捷，开发成本和维护成本要更低，要能够快速地更新进化，新功能要在最短的周期内上线。</li>
<li>客户端/api支持，因为这直接影响开发效率</li>
<li>部署简单</li>
<li>扩展能力强</li>
<li>节省系统资源，对cpu等资源耗费较小</li>
<li>有现成的文件系统 GridFS</li>
<li>大数据量访问，数据频繁更新</li>
<li>弱事务</li>
<li>高密集的IO、大量数据的存储及查询、数据的扩展、分布式</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Will</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yunheli" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyunhehappy6@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Will</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
